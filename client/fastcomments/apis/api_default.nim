#
# fastcomments
# 
# No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
# The version of the OpenAPI document: 0.0.0
# 
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_add_domain_config_params
import ../models/model_add_domain_config200response
import ../models/model_add_page_api_response
import ../models/model_add_sso_user_api_response
import ../models/model_aggregate_question_results200response
import ../models/model_aggregate_time_bucket
import ../models/model_aggregation_request
import ../models/model_aggregation_response
import ../models/model_block_from_comment_params
import ../models/model_block_from_comment_public200response
import ../models/model_bulk_aggregate_question_results_request
import ../models/model_bulk_aggregate_question_results200response
import ../models/model_combine_comments_with_question_results200response
import ../models/model_create_api_page_data
import ../models/model_create_apisso_user_data
import ../models/model_create_api_user_subscription_data
import ../models/model_create_comment_params
import ../models/model_create_feed_post_params
import ../models/model_create_feed_post200response
import ../models/model_create_subscription_api_response
import ../models/model_create_user_badge_params
import ../models/model_create_user_badge200response
import ../models/model_delete_comment200response
import ../models/model_delete_domain_config200response
import ../models/model_delete_page_api_response
import ../models/model_delete_sso_user_api_response
import ../models/model_delete_subscription_api_response
import ../models/model_feed_post
import ../models/model_flag_comment_public200response
import ../models/model_flag_comment200response
import ../models/model_get_audit_logs200response
import ../models/model_get_comment200response
import ../models/model_get_comments200response
import ../models/model_get_domain_config200response
import ../models/model_get_domain_configs200response
import ../models/model_get_feed_posts200response
import ../models/model_get_page_by_urlid_api_response
import ../models/model_get_pages_api_response
import ../models/model_get_sso_user_by_email_api_response
import ../models/model_get_sso_user_by_id_api_response
import ../models/model_get_sso_users200response
import ../models/model_get_subscriptions_api_response
import ../models/model_get_user_badge_progress_by_id200response
import ../models/model_get_user_badge_progress_list200response
import ../models/model_get_user_badge200response
import ../models/model_get_user_badges200response
import ../models/model_patch_domain_config_params
import ../models/model_patch_page_api_response
import ../models/model_patch_sso_user_api_response
import ../models/model_put_sso_user_api_response
import ../models/model_sort_dir
import ../models/model_save_comment200response
import ../models/model_sort_directions
import ../models/model_un_block_comment_public200response
import ../models/model_un_block_from_comment_params
import ../models/model_updatable_comment_params
import ../models/model_update_api_page_data
import ../models/model_update_apisso_user_data
import ../models/model_update_domain_config_params
import ../models/model_update_user_badge_params
import ../models/model_update_user_badge200response

const basepath = "https://fastcomments.com"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      (some(to(parseJson(response.body), T)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc addDomainConfig*(httpClient: HttpClient, tenantId: string, addDomainConfigParams: AddDomainConfigParams): (Option[AddDomainConfig_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & "/api/v1/domain-configs" & "?" & url_encoded_query_params, $(%addDomainConfigParams))
  constructResult[AddDomainConfig_200_response](response)


proc addPage*(httpClient: HttpClient, tenantId: string, createAPIPageData: CreateAPIPageData): (Option[AddPageAPIResponse], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & "/api/v1/pages" & "?" & url_encoded_query_params, $(%createAPIPageData))
  constructResult[AddPageAPIResponse](response)


proc addSSOUser*(httpClient: HttpClient, tenantId: string, createAPISSOUserData: CreateAPISSOUserData): (Option[AddSSOUserAPIResponse], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & "/api/v1/sso-users" & "?" & url_encoded_query_params, $(%createAPISSOUserData))
  constructResult[AddSSOUserAPIResponse](response)


proc aggregate*(httpClient: HttpClient, tenantId: string, aggregationRequest: AggregationRequest, parentTenantId: string, includeStats: bool): (Option[AggregationResponse], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $parentTenantId != "":
    query_params_list.add(("parentTenantId", $parentTenantId))
  if $includeStats != "":
    query_params_list.add(("includeStats", $includeStats))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & "/api/v1/aggregate" & "?" & url_encoded_query_params, $(%aggregationRequest))
  constructResult[AggregationResponse](response)


proc aggregateQuestionResults*(httpClient: HttpClient, tenantId: string, questionId: string, questionIds: seq[string], urlId: string, timeBucket: AggregateTimeBucket, startDate: string, forceRecalculate: bool): (Option[AggregateQuestionResults_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $questionId != "":
    query_params_list.add(("questionId", $questionId))
  if questionIds.len > 0:
    query_params_list.add(("questionIds", $questionIds.join(",")))
  if $urlId != "":
    query_params_list.add(("urlId", $urlId))
  if $timeBucket != "":
    query_params_list.add(("timeBucket", $timeBucket))
  if $startDate != "":
    query_params_list.add(("startDate", $startDate))
  if $forceRecalculate != "":
    query_params_list.add(("forceRecalculate", $forceRecalculate))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v1/question-results-aggregation" & "?" & url_encoded_query_params)
  constructResult[AggregateQuestionResults_200_response](response)


proc blockUserFromComment*(httpClient: HttpClient, tenantId: string, id: string, blockFromCommentParams: BlockFromCommentParams, userId: string, anonUserId: string): (Option[BlockFromCommentPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $userId != "":
    query_params_list.add(("userId", $userId))
  if $anonUserId != "":
    query_params_list.add(("anonUserId", $anonUserId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/api/v1/comments/{id}/block" & "?" & url_encoded_query_params, $(%blockFromCommentParams))
  constructResult[BlockFromCommentPublic_200_response](response)


proc bulkAggregateQuestionResults*(httpClient: HttpClient, tenantId: string, bulkAggregateQuestionResultsRequest: BulkAggregateQuestionResultsRequest, forceRecalculate: bool): (Option[BulkAggregateQuestionResults_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $forceRecalculate != "":
    query_params_list.add(("forceRecalculate", $forceRecalculate))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & "/api/v1/question-results-aggregation/bulk" & "?" & url_encoded_query_params, $(%bulkAggregateQuestionResultsRequest))
  constructResult[BulkAggregateQuestionResults_200_response](response)


proc combineCommentsWithQuestionResults*(httpClient: HttpClient, tenantId: string, questionId: string, questionIds: seq[string], urlId: string, startDate: string, forceRecalculate: bool, minValue: float64, maxValue: float64, limit: float64): (Option[CombineCommentsWithQuestionResults_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $questionId != "":
    query_params_list.add(("questionId", $questionId))
  if questionIds.len > 0:
    query_params_list.add(("questionIds", $questionIds.join(",")))
  if $urlId != "":
    query_params_list.add(("urlId", $urlId))
  if $startDate != "":
    query_params_list.add(("startDate", $startDate))
  if $forceRecalculate != "":
    query_params_list.add(("forceRecalculate", $forceRecalculate))
  if $minValue != "":
    query_params_list.add(("minValue", $minValue))
  if $maxValue != "":
    query_params_list.add(("maxValue", $maxValue))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v1/question-results-aggregation/combine/comments" & "?" & url_encoded_query_params)
  constructResult[CombineCommentsWithQuestionResults_200_response](response)


proc createFeedPost*(httpClient: HttpClient, tenantId: string, createFeedPostParams: CreateFeedPostParams, broadcastId: string, isLive: bool, doSpamCheck: bool, skipDupCheck: bool): (Option[CreateFeedPost_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $broadcastId != "":
    query_params_list.add(("broadcastId", $broadcastId))
  if $isLive != "":
    query_params_list.add(("isLive", $isLive))
  if $doSpamCheck != "":
    query_params_list.add(("doSpamCheck", $doSpamCheck))
  if $skipDupCheck != "":
    query_params_list.add(("skipDupCheck", $skipDupCheck))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & "/api/v1/feed-posts" & "?" & url_encoded_query_params, $(%createFeedPostParams))
  constructResult[CreateFeedPost_200_response](response)


proc createSubscription*(httpClient: HttpClient, tenantId: string, createAPIUserSubscriptionData: CreateAPIUserSubscriptionData): (Option[CreateSubscriptionAPIResponse], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & "/api/v1/subscriptions" & "?" & url_encoded_query_params, $(%createAPIUserSubscriptionData))
  constructResult[CreateSubscriptionAPIResponse](response)


proc createUserBadge*(httpClient: HttpClient, tenantId: string, createUserBadgeParams: CreateUserBadgeParams): (Option[CreateUserBadge_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & "/api/v1/user-badges" & "?" & url_encoded_query_params, $(%createUserBadgeParams))
  constructResult[CreateUserBadge_200_response](response)


proc deleteComment*(httpClient: HttpClient, tenantId: string, id: string, contextUserId: string, isLive: bool): (Option[DeleteComment_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $contextUserId != "":
    query_params_list.add(("contextUserId", $contextUserId))
  if $isLive != "":
    query_params_list.add(("isLive", $isLive))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.delete(basepath & fmt"/api/v1/comments/{id}" & "?" & url_encoded_query_params)
  constructResult[DeleteComment_200_response](response)


proc deleteDomainConfig*(httpClient: HttpClient, tenantId: string, domain: string): (Option[DeleteDomainConfig_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.delete(basepath & fmt"/api/v1/domain-configs/{domain}" & "?" & url_encoded_query_params)
  constructResult[DeleteDomainConfig_200_response](response)


proc deletePage*(httpClient: HttpClient, tenantId: string, id: string): (Option[DeletePageAPIResponse], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.delete(basepath & fmt"/api/v1/pages/{id}" & "?" & url_encoded_query_params)
  constructResult[DeletePageAPIResponse](response)


proc deleteSSOUser*(httpClient: HttpClient, tenantId: string, id: string, deleteComments: bool, commentDeleteMode: string): (Option[DeleteSSOUserAPIResponse], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $deleteComments != "":
    query_params_list.add(("deleteComments", $deleteComments))
  if $commentDeleteMode != "":
    query_params_list.add(("commentDeleteMode", $commentDeleteMode))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.delete(basepath & fmt"/api/v1/sso-users/{id}" & "?" & url_encoded_query_params)
  constructResult[DeleteSSOUserAPIResponse](response)


proc deleteSubscription*(httpClient: HttpClient, tenantId: string, id: string, userId: string): (Option[DeleteSubscriptionAPIResponse], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $userId != "":
    query_params_list.add(("userId", $userId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.delete(basepath & fmt"/api/v1/subscriptions/{id}" & "?" & url_encoded_query_params)
  constructResult[DeleteSubscriptionAPIResponse](response)


proc deleteUserBadge*(httpClient: HttpClient, tenantId: string, id: string): (Option[UpdateUserBadge_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.delete(basepath & fmt"/api/v1/user-badges/{id}" & "?" & url_encoded_query_params)
  constructResult[UpdateUserBadge_200_response](response)


proc flagComment*(httpClient: HttpClient, tenantId: string, id: string, userId: string, anonUserId: string): (Option[FlagComment_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $userId != "":
    query_params_list.add(("userId", $userId))
  if $anonUserId != "":
    query_params_list.add(("anonUserId", $anonUserId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/api/v1/comments/{id}/flag" & "?" & url_encoded_query_params)
  constructResult[FlagComment_200_response](response)


proc getAuditLogs*(httpClient: HttpClient, tenantId: string, limit: float64, skip: float64, order: SORTDIR, after: float64, before: float64): (Option[GetAuditLogs_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $skip != "":
    query_params_list.add(("skip", $skip))
  if $order != "":
    query_params_list.add(("order", $order))
  if $after != "":
    query_params_list.add(("after", $after))
  if $before != "":
    query_params_list.add(("before", $before))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v1/audit-logs" & "?" & url_encoded_query_params)
  constructResult[GetAuditLogs_200_response](response)


proc getComment*(httpClient: HttpClient, tenantId: string, id: string): (Option[GetComment_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/api/v1/comments/{id}" & "?" & url_encoded_query_params)
  constructResult[GetComment_200_response](response)


proc getComments*(httpClient: HttpClient, tenantId: string, page: int, limit: int, skip: int, asTree: bool, skipChildren: int, limitChildren: int, maxTreeDepth: int, urlId: string, userId: string, anonUserId: string, contextUserId: string, hashTag: string, parentId: string, direction: SortDirections): (Option[GetComments_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $page != "":
    query_params_list.add(("page", $page))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $skip != "":
    query_params_list.add(("skip", $skip))
  if $asTree != "":
    query_params_list.add(("asTree", $asTree))
  if $skipChildren != "":
    query_params_list.add(("skipChildren", $skipChildren))
  if $limitChildren != "":
    query_params_list.add(("limitChildren", $limitChildren))
  if $maxTreeDepth != "":
    query_params_list.add(("maxTreeDepth", $maxTreeDepth))
  if $urlId != "":
    query_params_list.add(("urlId", $urlId))
  if $userId != "":
    query_params_list.add(("userId", $userId))
  if $anonUserId != "":
    query_params_list.add(("anonUserId", $anonUserId))
  if $contextUserId != "":
    query_params_list.add(("contextUserId", $contextUserId))
  if $hashTag != "":
    query_params_list.add(("hashTag", $hashTag))
  if $parentId != "":
    query_params_list.add(("parentId", $parentId))
  if $direction != "":
    query_params_list.add(("direction", $direction))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v1/comments" & "?" & url_encoded_query_params)
  constructResult[GetComments_200_response](response)


proc getDomainConfig*(httpClient: HttpClient, tenantId: string, domain: string): (Option[GetDomainConfig_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/api/v1/domain-configs/{domain}" & "?" & url_encoded_query_params)
  constructResult[GetDomainConfig_200_response](response)


proc getDomainConfigs*(httpClient: HttpClient, tenantId: string): (Option[GetDomainConfigs_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v1/domain-configs" & "?" & url_encoded_query_params)
  constructResult[GetDomainConfigs_200_response](response)


proc getFeedPosts*(httpClient: HttpClient, tenantId: string, afterId: string, limit: int, tags: seq[string]): (Option[GetFeedPosts_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $afterId != "":
    query_params_list.add(("afterId", $afterId))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if tags.len > 0:
    query_params_list.add(("tags", $tags.join(",")))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v1/feed-posts" & "?" & url_encoded_query_params)
  constructResult[GetFeedPosts_200_response](response)


proc getPageByURLId*(httpClient: HttpClient, tenantId: string, urlId: string): (Option[GetPageByURLIdAPIResponse], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  query_params_list.add(("urlId", $urlId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v1/pages/by-url-id" & "?" & url_encoded_query_params)
  constructResult[GetPageByURLIdAPIResponse](response)


proc getPages*(httpClient: HttpClient, tenantId: string): (Option[GetPagesAPIResponse], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v1/pages" & "?" & url_encoded_query_params)
  constructResult[GetPagesAPIResponse](response)


proc getSSOUserByEmail*(httpClient: HttpClient, tenantId: string, email: string): (Option[GetSSOUserByEmailAPIResponse], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/api/v1/sso-users/by-email/{email}" & "?" & url_encoded_query_params)
  constructResult[GetSSOUserByEmailAPIResponse](response)


proc getSSOUserById*(httpClient: HttpClient, tenantId: string, id: string): (Option[GetSSOUserByIdAPIResponse], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/api/v1/sso-users/by-id/{id}" & "?" & url_encoded_query_params)
  constructResult[GetSSOUserByIdAPIResponse](response)


proc getSSOUsers*(httpClient: HttpClient, tenantId: string, skip: int): (Option[GetSSOUsers_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $skip != "":
    query_params_list.add(("skip", $skip))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v1/sso-users" & "?" & url_encoded_query_params)
  constructResult[GetSSOUsers_200_response](response)


proc getSubscriptions*(httpClient: HttpClient, tenantId: string, userId: string): (Option[GetSubscriptionsAPIResponse], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $userId != "":
    query_params_list.add(("userId", $userId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v1/subscriptions" & "?" & url_encoded_query_params)
  constructResult[GetSubscriptionsAPIResponse](response)


proc getUserBadge*(httpClient: HttpClient, tenantId: string, id: string): (Option[GetUserBadge_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/api/v1/user-badges/{id}" & "?" & url_encoded_query_params)
  constructResult[GetUserBadge_200_response](response)


proc getUserBadgeProgressById*(httpClient: HttpClient, tenantId: string, id: string): (Option[GetUserBadgeProgressById_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/api/v1/user-badge-progress/{id}" & "?" & url_encoded_query_params)
  constructResult[GetUserBadgeProgressById_200_response](response)


proc getUserBadgeProgressByUserId*(httpClient: HttpClient, tenantId: string, userId: string): (Option[GetUserBadgeProgressById_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/api/v1/user-badge-progress/user/{userId}" & "?" & url_encoded_query_params)
  constructResult[GetUserBadgeProgressById_200_response](response)


proc getUserBadgeProgressList*(httpClient: HttpClient, tenantId: string, userId: string, limit: float64, skip: float64): (Option[GetUserBadgeProgressList_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $userId != "":
    query_params_list.add(("userId", $userId))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $skip != "":
    query_params_list.add(("skip", $skip))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v1/user-badge-progress" & "?" & url_encoded_query_params)
  constructResult[GetUserBadgeProgressList_200_response](response)


proc getUserBadges*(httpClient: HttpClient, tenantId: string, userId: string, badgeId: string, `type`: float64, displayedOnComments: bool, limit: float64, skip: float64): (Option[GetUserBadges_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $userId != "":
    query_params_list.add(("userId", $userId))
  if $badgeId != "":
    query_params_list.add(("badgeId", $badgeId))
  if $`type` != "":
    query_params_list.add(("type", $`type`))
  if $displayedOnComments != "":
    query_params_list.add(("displayedOnComments", $displayedOnComments))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $skip != "":
    query_params_list.add(("skip", $skip))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v1/user-badges" & "?" & url_encoded_query_params)
  constructResult[GetUserBadges_200_response](response)


proc patchDomainConfig*(httpClient: HttpClient, tenantId: string, domainToUpdate: string, patchDomainConfigParams: PatchDomainConfigParams): (Option[GetDomainConfig_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.patch(basepath & fmt"/api/v1/domain-configs/{domainToUpdate}" & "?" & url_encoded_query_params, $(%patchDomainConfigParams))
  constructResult[GetDomainConfig_200_response](response)


proc patchPage*(httpClient: HttpClient, tenantId: string, id: string, updateAPIPageData: UpdateAPIPageData): (Option[PatchPageAPIResponse], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.patch(basepath & fmt"/api/v1/pages/{id}" & "?" & url_encoded_query_params, $(%updateAPIPageData))
  constructResult[PatchPageAPIResponse](response)


proc patchSSOUser*(httpClient: HttpClient, tenantId: string, id: string, updateAPISSOUserData: UpdateAPISSOUserData, updateComments: bool): (Option[PatchSSOUserAPIResponse], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $updateComments != "":
    query_params_list.add(("updateComments", $updateComments))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.patch(basepath & fmt"/api/v1/sso-users/{id}" & "?" & url_encoded_query_params, $(%updateAPISSOUserData))
  constructResult[PatchSSOUserAPIResponse](response)


proc putDomainConfig*(httpClient: HttpClient, tenantId: string, domainToUpdate: string, updateDomainConfigParams: UpdateDomainConfigParams): (Option[GetDomainConfig_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.put(basepath & fmt"/api/v1/domain-configs/{domainToUpdate}" & "?" & url_encoded_query_params, $(%updateDomainConfigParams))
  constructResult[GetDomainConfig_200_response](response)


proc putSSOUser*(httpClient: HttpClient, tenantId: string, id: string, updateAPISSOUserData: UpdateAPISSOUserData, updateComments: bool): (Option[PutSSOUserAPIResponse], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $updateComments != "":
    query_params_list.add(("updateComments", $updateComments))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.put(basepath & fmt"/api/v1/sso-users/{id}" & "?" & url_encoded_query_params, $(%updateAPISSOUserData))
  constructResult[PutSSOUserAPIResponse](response)


proc saveComment*(httpClient: HttpClient, tenantId: string, createCommentParams: CreateCommentParams, isLive: bool, doSpamCheck: bool, sendEmails: bool, populateNotifications: bool): (Option[SaveComment_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $isLive != "":
    query_params_list.add(("isLive", $isLive))
  if $doSpamCheck != "":
    query_params_list.add(("doSpamCheck", $doSpamCheck))
  if $sendEmails != "":
    query_params_list.add(("sendEmails", $sendEmails))
  if $populateNotifications != "":
    query_params_list.add(("populateNotifications", $populateNotifications))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & "/api/v1/comments" & "?" & url_encoded_query_params, $(%createCommentParams))
  constructResult[SaveComment_200_response](response)


proc saveCommentsBulk*(httpClient: HttpClient, tenantId: string, createCommentParams: seq[CreateCommentParams], isLive: bool, doSpamCheck: bool, sendEmails: bool, populateNotifications: bool): (Option[seq[SaveComment_200_response]], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $isLive != "":
    query_params_list.add(("isLive", $isLive))
  if $doSpamCheck != "":
    query_params_list.add(("doSpamCheck", $doSpamCheck))
  if $sendEmails != "":
    query_params_list.add(("sendEmails", $sendEmails))
  if $populateNotifications != "":
    query_params_list.add(("populateNotifications", $populateNotifications))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & "/api/v1/comments/bulk" & "?" & url_encoded_query_params, $(%createCommentParams))
  constructResult[seq[SaveComment_200_response]](response)


proc unBlockUserFromComment*(httpClient: HttpClient, tenantId: string, id: string, unBlockFromCommentParams: UnBlockFromCommentParams, userId: string, anonUserId: string): (Option[UnBlockCommentPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $userId != "":
    query_params_list.add(("userId", $userId))
  if $anonUserId != "":
    query_params_list.add(("anonUserId", $anonUserId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/api/v1/comments/{id}/un-block" & "?" & url_encoded_query_params, $(%unBlockFromCommentParams))
  constructResult[UnBlockCommentPublic_200_response](response)


proc unFlagComment*(httpClient: HttpClient, tenantId: string, id: string, userId: string, anonUserId: string): (Option[FlagComment_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $userId != "":
    query_params_list.add(("userId", $userId))
  if $anonUserId != "":
    query_params_list.add(("anonUserId", $anonUserId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/api/v1/comments/{id}/un-flag" & "?" & url_encoded_query_params)
  constructResult[FlagComment_200_response](response)


proc updateComment*(httpClient: HttpClient, tenantId: string, id: string, updatableCommentParams: UpdatableCommentParams, contextUserId: string, doSpamCheck: bool, isLive: bool): (Option[FlagCommentPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $contextUserId != "":
    query_params_list.add(("contextUserId", $contextUserId))
  if $doSpamCheck != "":
    query_params_list.add(("doSpamCheck", $doSpamCheck))
  if $isLive != "":
    query_params_list.add(("isLive", $isLive))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.patch(basepath & fmt"/api/v1/comments/{id}" & "?" & url_encoded_query_params, $(%updatableCommentParams))
  constructResult[FlagCommentPublic_200_response](response)


proc updateFeedPost*(httpClient: HttpClient, tenantId: string, id: string, feedPost: FeedPost): (Option[FlagCommentPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.patch(basepath & fmt"/api/v1/feed-posts/{id}" & "?" & url_encoded_query_params, $(%feedPost))
  constructResult[FlagCommentPublic_200_response](response)


proc updateUserBadge*(httpClient: HttpClient, tenantId: string, id: string, updateUserBadgeParams: UpdateUserBadgeParams): (Option[UpdateUserBadge_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.put(basepath & fmt"/api/v1/user-badges/{id}" & "?" & url_encoded_query_params, $(%updateUserBadgeParams))
  constructResult[UpdateUserBadge_200_response](response)

