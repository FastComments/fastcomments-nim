#
# fastcomments
# 
# No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
# The version of the OpenAPI document: 0.0.0
# 
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_api_error
import ../models/model_block_from_comment_public200response
import ../models/model_checked_comments_for_blocked200response
import ../models/model_comment_data
import ../models/model_comment_text_update_request
import ../models/model_create_comment_public200response
import ../models/model_create_feed_post_params
import ../models/model_create_feed_post_public200response
import ../models/model_delete_comment_public200response
import ../models/model_delete_comment_vote200response
import ../models/model_delete_feed_post_public200response
import ../models/model_flag_comment_public200response
import ../models/model_get_comment_text200response
import ../models/model_get_comment_vote_user_names200response
import ../models/model_get_comments_public200response
import ../models/model_get_event_log200response
import ../models/model_get_feed_posts_public200response
import ../models/model_get_feed_posts_stats200response
import ../models/model_get_user_notification_count200response
import ../models/model_get_user_notifications200response
import ../models/model_get_user_presence_statuses200response
import ../models/model_get_user_reacts_public200response
import ../models/model_lock_comment200response
import ../models/model_pin_comment200response
import ../models/model_public_block_from_comment_params
import ../models/model_react_body_params
import ../models/model_react_feed_post_public200response
import ../models/model_reset_user_notifications200response
import ../models/model_search_users200response
import ../models/model_set_comment_text200response
import ../models/model_size_preset
import ../models/model_sort_directions
import ../models/model_un_block_comment_public200response
import ../models/model_update_feed_post_params
import ../models/model_update_user_notification_status200response
import ../models/model_upload_image_response
import ../models/model_vote_body_params
import ../models/model_vote_comment200response

const basepath = "https://fastcomments.com"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      when name(stripGenericParams(T.typedesc).typedesc) == name(Table):
        (some(json.to(parseJson(response.body), T.typedesc)), response)
      else:
        (some(marshal.to[T](response.body)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc blockFromCommentPublic*(httpClient: HttpClient, tenantId: string, commentId: string, publicBlockFromCommentParams: PublicBlockFromCommentParams, sso: string): (Option[BlockFromCommentPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  let url_encoded_query_params = encodeQuery([
    ("tenantId", $tenantId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/block-from-comment/{commentId}" & "?" & url_encoded_query_params, $(%publicBlockFromCommentParams))
  constructResult[BlockFromCommentPublic_200_response](response)


proc checkedCommentsForBlocked*(httpClient: HttpClient, tenantId: string, commentIds: string, sso: string): (Option[CheckedCommentsForBlocked_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("tenantId", $tenantId), # 
    ("commentIds", $commentIds), # A comma separated list of comment ids.
    ("sso", $sso), # 
  ])

  let response = httpClient.get(basepath & "/check-blocked-comments" & "?" & url_encoded_query_params)
  constructResult[CheckedCommentsForBlocked_200_response](response)


proc createCommentPublic*(httpClient: HttpClient, tenantId: string, urlId: string, broadcastId: string, commentData: CommentData, sessionId: string, sso: string): (Option[CreateCommentPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  let url_encoded_query_params = encodeQuery([
    ("urlId", $urlId), # 
    ("broadcastId", $broadcastId), # 
    ("sessionId", $sessionId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}" & "?" & url_encoded_query_params, $(%commentData))
  constructResult[CreateCommentPublic_200_response](response)


proc createFeedPostPublic*(httpClient: HttpClient, tenantId: string, createFeedPostParams: CreateFeedPostParams, broadcastId: string, sso: string): (Option[CreateFeedPostPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  let url_encoded_query_params = encodeQuery([
    ("broadcastId", $broadcastId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/feed-posts/{tenantId}" & "?" & url_encoded_query_params, $(%createFeedPostParams))
  constructResult[CreateFeedPostPublic_200_response](response)


proc deleteCommentPublic*(httpClient: HttpClient, tenantId: string, commentId: string, broadcastId: string, editKey: string, sso: string): (Option[DeleteCommentPublic_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("broadcastId", $broadcastId), # 
    ("editKey", $editKey), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.delete(basepath & fmt"/comments/{tenantId}/{commentId}" & "?" & url_encoded_query_params)
  constructResult[DeleteCommentPublic_200_response](response)


proc deleteCommentVote*(httpClient: HttpClient, tenantId: string, commentId: string, voteId: string, urlId: string, broadcastId: string, editKey: string, sso: string): (Option[DeleteCommentVote_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("urlId", $urlId), # 
    ("broadcastId", $broadcastId), # 
    ("editKey", $editKey), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.delete(basepath & fmt"/comments/{tenantId}/{commentId}/vote/{voteId}" & "?" & url_encoded_query_params)
  constructResult[DeleteCommentVote_200_response](response)


proc deleteFeedPostPublic*(httpClient: HttpClient, tenantId: string, postId: string, broadcastId: string, sso: string): (Option[DeleteFeedPostPublic_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("broadcastId", $broadcastId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.delete(basepath & fmt"/feed-posts/{tenantId}/{postId}" & "?" & url_encoded_query_params)
  constructResult[DeleteFeedPostPublic_200_response](response)


proc flagCommentPublic*(httpClient: HttpClient, tenantId: string, commentId: string, isFlagged: bool, sso: string): (Option[FlagCommentPublic_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("tenantId", $tenantId), # 
    ("isFlagged", $isFlagged), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/flag-comment/{commentId}" & "?" & url_encoded_query_params)
  constructResult[FlagCommentPublic_200_response](response)


proc getCommentText*(httpClient: HttpClient, tenantId: string, commentId: string, editKey: string, sso: string): (Option[GetCommentText_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("editKey", $editKey), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.get(basepath & fmt"/comments/{tenantId}/{commentId}/text" & "?" & url_encoded_query_params)
  constructResult[GetCommentText_200_response](response)


proc getCommentVoteUserNames*(httpClient: HttpClient, tenantId: string, commentId: string, dir: int, sso: string): (Option[GetCommentVoteUserNames_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("dir", $dir), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.get(basepath & fmt"/comments/{tenantId}/{commentId}/votes" & "?" & url_encoded_query_params)
  constructResult[GetCommentVoteUserNames_200_response](response)


proc getCommentsPublic*(httpClient: HttpClient, tenantId: string, urlId: string, page: int, direction: SortDirections, sso: string, skip: int, skipChildren: int, limit: int, limitChildren: int, countChildren: bool, fetchPageForCommentId: string, includeConfig: bool, countAll: bool, includei10n: bool, locale: string, modules: string, isCrawler: bool, includeNotificationCount: bool, asTree: bool, maxTreeDepth: int, useFullTranslationIds: bool, parentId: string, searchText: string, hashTags: seq[string], userId: string, customConfigStr: string, afterCommentId: string, beforeCommentId: string): (Option[GetCommentsPublic_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("urlId", $urlId), # 
    ("page", $page), # 
    ("direction", $direction), # 
    ("sso", $sso), # 
    ("skip", $skip), # 
    ("skipChildren", $skipChildren), # 
    ("limit", $limit), # 
    ("limitChildren", $limitChildren), # 
    ("countChildren", $countChildren), # 
    ("fetchPageForCommentId", $fetchPageForCommentId), # 
    ("includeConfig", $includeConfig), # 
    ("countAll", $countAll), # 
    ("includei10n", $includei10n), # 
    ("locale", $locale), # 
    ("modules", $modules), # 
    ("isCrawler", $isCrawler), # 
    ("includeNotificationCount", $includeNotificationCount), # 
    ("asTree", $asTree), # 
    ("maxTreeDepth", $maxTreeDepth), # 
    ("useFullTranslationIds", $useFullTranslationIds), # 
    ("parentId", $parentId), # 
    ("searchText", $searchText), # 
    ("hashTags", $hashTags.join(",")), # 
    ("userId", $userId), # 
    ("customConfigStr", $customConfigStr), # 
    ("afterCommentId", $afterCommentId), # 
    ("beforeCommentId", $beforeCommentId), # 
  ])

  let response = httpClient.get(basepath & fmt"/comments/{tenantId}" & "?" & url_encoded_query_params)
  constructResult[GetCommentsPublic_200_response](response)


proc getEventLog*(httpClient: HttpClient, tenantId: string, urlId: string, userIdWS: string, startTime: int64, endTime: int64): (Option[GetEventLog_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("urlId", $urlId), # 
    ("userIdWS", $userIdWS), # 
    ("startTime", $startTime), # 
    ("endTime", $endTime), # 
  ])

  let response = httpClient.get(basepath & fmt"/event-log/{tenantId}" & "?" & url_encoded_query_params)
  constructResult[GetEventLog_200_response](response)


proc getFeedPostsPublic*(httpClient: HttpClient, tenantId: string, afterId: string, limit: int, tags: seq[string], sso: string, isCrawler: bool, includeUserInfo: bool): (Option[GetFeedPostsPublic_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("afterId", $afterId), # 
    ("limit", $limit), # 
    ("tags", $tags.join(",")), # 
    ("sso", $sso), # 
    ("isCrawler", $isCrawler), # 
    ("includeUserInfo", $includeUserInfo), # 
  ])

  let response = httpClient.get(basepath & fmt"/feed-posts/{tenantId}" & "?" & url_encoded_query_params)
  constructResult[GetFeedPostsPublic_200_response](response)


proc getFeedPostsStats*(httpClient: HttpClient, tenantId: string, postIds: seq[string], sso: string): (Option[GetFeedPostsStats_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("postIds", $postIds.join(",")), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.get(basepath & fmt"/feed-posts/{tenantId}/stats" & "?" & url_encoded_query_params)
  constructResult[GetFeedPostsStats_200_response](response)


proc getGlobalEventLog*(httpClient: HttpClient, tenantId: string, urlId: string, userIdWS: string, startTime: int64, endTime: int64): (Option[GetEventLog_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("urlId", $urlId), # 
    ("userIdWS", $userIdWS), # 
    ("startTime", $startTime), # 
    ("endTime", $endTime), # 
  ])

  let response = httpClient.get(basepath & fmt"/event-log/global/{tenantId}" & "?" & url_encoded_query_params)
  constructResult[GetEventLog_200_response](response)


proc getUserNotificationCount*(httpClient: HttpClient, tenantId: string, sso: string): (Option[GetUserNotificationCount_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("tenantId", $tenantId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.get(basepath & "/user-notifications/get-count" & "?" & url_encoded_query_params)
  constructResult[GetUserNotificationCount_200_response](response)


proc getUserNotifications*(httpClient: HttpClient, tenantId: string, pageSize: int, afterId: string, includeContext: bool, afterCreatedAt: int64, unreadOnly: bool, dmOnly: bool, noDm: bool, includeTranslations: bool, sso: string): (Option[GetUserNotifications_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("tenantId", $tenantId), # 
    ("pageSize", $pageSize), # 
    ("afterId", $afterId), # 
    ("includeContext", $includeContext), # 
    ("afterCreatedAt", $afterCreatedAt), # 
    ("unreadOnly", $unreadOnly), # 
    ("dmOnly", $dmOnly), # 
    ("noDm", $noDm), # 
    ("includeTranslations", $includeTranslations), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.get(basepath & "/user-notifications" & "?" & url_encoded_query_params)
  constructResult[GetUserNotifications_200_response](response)


proc getUserPresenceStatuses*(httpClient: HttpClient, tenantId: string, urlIdWS: string, userIds: string): (Option[GetUserPresenceStatuses_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("tenantId", $tenantId), # 
    ("urlIdWS", $urlIdWS), # 
    ("userIds", $userIds), # 
  ])

  let response = httpClient.get(basepath & "/user-presence-status" & "?" & url_encoded_query_params)
  constructResult[GetUserPresenceStatuses_200_response](response)


proc getUserReactsPublic*(httpClient: HttpClient, tenantId: string, postIds: seq[string], sso: string): (Option[GetUserReactsPublic_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("postIds", $postIds.join(",")), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.get(basepath & fmt"/feed-posts/{tenantId}/user-reacts" & "?" & url_encoded_query_params)
  constructResult[GetUserReactsPublic_200_response](response)


proc lockComment*(httpClient: HttpClient, tenantId: string, commentId: string, broadcastId: string, sso: string): (Option[LockComment_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("broadcastId", $broadcastId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}/{commentId}/lock" & "?" & url_encoded_query_params)
  constructResult[LockComment_200_response](response)


proc pinComment*(httpClient: HttpClient, tenantId: string, commentId: string, broadcastId: string, sso: string): (Option[PinComment_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("broadcastId", $broadcastId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}/{commentId}/pin" & "?" & url_encoded_query_params)
  constructResult[PinComment_200_response](response)


proc reactFeedPostPublic*(httpClient: HttpClient, tenantId: string, postId: string, reactBodyParams: ReactBodyParams, isUndo: bool, broadcastId: string, sso: string): (Option[ReactFeedPostPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  let url_encoded_query_params = encodeQuery([
    ("isUndo", $isUndo), # 
    ("broadcastId", $broadcastId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/feed-posts/{tenantId}/react/{postId}" & "?" & url_encoded_query_params, $(%reactBodyParams))
  constructResult[ReactFeedPostPublic_200_response](response)


proc resetUserNotificationCount*(httpClient: HttpClient, tenantId: string, sso: string): (Option[ResetUserNotifications_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("tenantId", $tenantId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & "/user-notifications/reset-count" & "?" & url_encoded_query_params)
  constructResult[ResetUserNotifications_200_response](response)


proc resetUserNotifications*(httpClient: HttpClient, tenantId: string, afterId: string, afterCreatedAt: int64, unreadOnly: bool, dmOnly: bool, noDm: bool, sso: string): (Option[ResetUserNotifications_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("tenantId", $tenantId), # 
    ("afterId", $afterId), # 
    ("afterCreatedAt", $afterCreatedAt), # 
    ("unreadOnly", $unreadOnly), # 
    ("dmOnly", $dmOnly), # 
    ("noDm", $noDm), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & "/user-notifications/reset" & "?" & url_encoded_query_params)
  constructResult[ResetUserNotifications_200_response](response)


proc searchUsers*(httpClient: HttpClient, tenantId: string, urlId: string, usernameStartsWith: string, mentionGroupIds: seq[string], sso: string): (Option[SearchUsers_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("urlId", $urlId), # 
    ("usernameStartsWith", $usernameStartsWith), # 
    ("mentionGroupIds", $mentionGroupIds.join(",")), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.get(basepath & fmt"/user-search/{tenantId}" & "?" & url_encoded_query_params)
  constructResult[SearchUsers_200_response](response)


proc setCommentText*(httpClient: HttpClient, tenantId: string, commentId: string, broadcastId: string, commentTextUpdateRequest: CommentTextUpdateRequest, editKey: string, sso: string): (Option[SetCommentText_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  let url_encoded_query_params = encodeQuery([
    ("broadcastId", $broadcastId), # 
    ("editKey", $editKey), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}/{commentId}/update-text" & "?" & url_encoded_query_params, $(%commentTextUpdateRequest))
  constructResult[SetCommentText_200_response](response)


proc unBlockCommentPublic*(httpClient: HttpClient, tenantId: string, commentId: string, publicBlockFromCommentParams: PublicBlockFromCommentParams, sso: string): (Option[UnBlockCommentPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  let url_encoded_query_params = encodeQuery([
    ("tenantId", $tenantId), # 
    ("sso", $sso), # 
  ])
  let response = httpClient.request(basepath & fmt"/block-from-comment/{commentId}" & "?" & url_encoded_query_params, httpMethod = HttpDelete, body = $(%publicBlockFromCommentParams))
  constructResult[UnBlockCommentPublic_200_response](response)


proc unLockComment*(httpClient: HttpClient, tenantId: string, commentId: string, broadcastId: string, sso: string): (Option[LockComment_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("broadcastId", $broadcastId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}/{commentId}/unlock" & "?" & url_encoded_query_params)
  constructResult[LockComment_200_response](response)


proc unPinComment*(httpClient: HttpClient, tenantId: string, commentId: string, broadcastId: string, sso: string): (Option[PinComment_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("broadcastId", $broadcastId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}/{commentId}/unpin" & "?" & url_encoded_query_params)
  constructResult[PinComment_200_response](response)


proc updateFeedPostPublic*(httpClient: HttpClient, tenantId: string, postId: string, updateFeedPostParams: UpdateFeedPostParams, broadcastId: string, sso: string): (Option[CreateFeedPostPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  let url_encoded_query_params = encodeQuery([
    ("broadcastId", $broadcastId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.put(basepath & fmt"/feed-posts/{tenantId}/{postId}" & "?" & url_encoded_query_params, $(%updateFeedPostParams))
  constructResult[CreateFeedPostPublic_200_response](response)


proc updateUserNotificationCommentSubscriptionStatus*(httpClient: HttpClient, tenantId: string, notificationId: string, optedInOrOut: string, commentId: string, sso: string): (Option[UpdateUserNotificationStatus_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("tenantId", $tenantId), # 
    ("commentId", $commentId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/user-notifications/{notificationId}/mark-opted/{optedInOrOut}" & "?" & url_encoded_query_params)
  constructResult[UpdateUserNotificationStatus_200_response](response)


proc updateUserNotificationPageSubscriptionStatus*(httpClient: HttpClient, tenantId: string, urlId: string, url: string, pageTitle: string, subscribedOrUnsubscribed: string, sso: string): (Option[UpdateUserNotificationStatus_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("tenantId", $tenantId), # 
    ("urlId", $urlId), # 
    ("url", $url), # 
    ("pageTitle", $pageTitle), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/user-notifications/set-subscription-state/{subscribedOrUnsubscribed}" & "?" & url_encoded_query_params)
  constructResult[UpdateUserNotificationStatus_200_response](response)


proc updateUserNotificationStatus*(httpClient: HttpClient, tenantId: string, notificationId: string, newStatus: string, sso: string): (Option[UpdateUserNotificationStatus_200_response], Response) =
  ## 
  let url_encoded_query_params = encodeQuery([
    ("tenantId", $tenantId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/user-notifications/{notificationId}/mark/{newStatus}" & "?" & url_encoded_query_params)
  constructResult[UpdateUserNotificationStatus_200_response](response)


proc uploadImage*(httpClient: HttpClient, tenantId: string, file: string, sizePreset: SizePreset, urlId: string): (Option[UploadImageResponse], Response) =
  ## 
  httpClient.headers["Content-Type"] = "multipart/form-data"
  let url_encoded_query_params = encodeQuery([
    ("sizePreset", $sizePreset), # Size preset: \"Default\" (1000x1000px) or \"CrossPlatform\" (creates sizes for popular devices)
    ("urlId", $urlId), # Page id that upload is happening from, to configure
  ])
  let multipart_data = newMultipartData({
    "file": $file, # 
  })

  let response = httpClient.post(basepath & fmt"/upload-image/{tenantId}" & "?" & url_encoded_query_params, multipart=multipart_data)
  constructResult[UploadImageResponse](response)


proc voteComment*(httpClient: HttpClient, tenantId: string, commentId: string, urlId: string, broadcastId: string, voteBodyParams: VoteBodyParams, sessionId: string, sso: string): (Option[VoteComment_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  let url_encoded_query_params = encodeQuery([
    ("urlId", $urlId), # 
    ("broadcastId", $broadcastId), # 
    ("sessionId", $sessionId), # 
    ("sso", $sso), # 
  ])

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}/{commentId}/vote" & "?" & url_encoded_query_params, $(%voteBodyParams))
  constructResult[VoteComment_200_response](response)

