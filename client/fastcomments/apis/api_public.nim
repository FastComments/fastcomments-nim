#
# fastcomments
# 
# No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
# The version of the OpenAPI document: 0.0.0
# 
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_api_error
import ../models/model_block_from_comment_public200response
import ../models/model_checked_comments_for_blocked200response
import ../models/model_comment_data
import ../models/model_comment_text_update_request
import ../models/model_create_comment_public200response
import ../models/model_create_feed_post_params
import ../models/model_create_feed_post_public200response
import ../models/model_delete_comment_public200response
import ../models/model_delete_comment_vote200response
import ../models/model_delete_feed_post_public200response
import ../models/model_flag_comment_public200response
import ../models/model_get_comment_text200response
import ../models/model_get_comment_vote_user_names200response
import ../models/model_get_comments_public200response
import ../models/model_get_event_log200response
import ../models/model_get_feed_posts_public200response
import ../models/model_get_feed_posts_stats200response
import ../models/model_get_user_notification_count200response
import ../models/model_get_user_notifications200response
import ../models/model_get_user_presence_statuses200response
import ../models/model_get_user_reacts_public200response
import ../models/model_lock_comment200response
import ../models/model_pin_comment200response
import ../models/model_public_block_from_comment_params
import ../models/model_react_body_params
import ../models/model_react_feed_post_public200response
import ../models/model_reset_user_notifications200response
import ../models/model_search_users200response
import ../models/model_set_comment_text200response
import ../models/model_size_preset
import ../models/model_sort_directions
import ../models/model_un_block_comment_public200response
import ../models/model_update_feed_post_params
import ../models/model_update_user_notification_status200response
import ../models/model_upload_image_response
import ../models/model_vote_body_params
import ../models/model_vote_comment200response

const basepath = "https://fastcomments.com"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      (some(to(parseJson(response.body), T)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc blockFromCommentPublic*(httpClient: HttpClient, tenantId: string, commentId: string, publicBlockFromCommentParams: PublicBlockFromCommentParams, sso: string): (Option[BlockFromCommentPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/block-from-comment/{commentId}" & "?" & url_encoded_query_params, $(%publicBlockFromCommentParams))
  constructResult[BlockFromCommentPublic_200_response](response)


proc checkedCommentsForBlocked*(httpClient: HttpClient, tenantId: string, commentIds: string, sso: string): (Option[CheckedCommentsForBlocked_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  query_params_list.add(("commentIds", $commentIds))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/check-blocked-comments" & "?" & url_encoded_query_params)
  constructResult[CheckedCommentsForBlocked_200_response](response)


proc createCommentPublic*(httpClient: HttpClient, tenantId: string, urlId: string, broadcastId: string, commentData: CommentData, sessionId: string, sso: string): (Option[CreateCommentPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("urlId", $urlId))
  query_params_list.add(("broadcastId", $broadcastId))
  if $sessionId != "":
    query_params_list.add(("sessionId", $sessionId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}" & "?" & url_encoded_query_params, $(%commentData))
  constructResult[CreateCommentPublic_200_response](response)


proc createFeedPostPublic*(httpClient: HttpClient, tenantId: string, createFeedPostParams: CreateFeedPostParams, broadcastId: string, sso: string): (Option[CreateFeedPostPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  if $broadcastId != "":
    query_params_list.add(("broadcastId", $broadcastId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/feed-posts/{tenantId}" & "?" & url_encoded_query_params, $(%createFeedPostParams))
  constructResult[CreateFeedPostPublic_200_response](response)


proc deleteCommentPublic*(httpClient: HttpClient, tenantId: string, commentId: string, broadcastId: string, editKey: string, sso: string): (Option[DeleteCommentPublic_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("broadcastId", $broadcastId))
  if $editKey != "":
    query_params_list.add(("editKey", $editKey))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.delete(basepath & fmt"/comments/{tenantId}/{commentId}" & "?" & url_encoded_query_params)
  constructResult[DeleteCommentPublic_200_response](response)


proc deleteCommentVote*(httpClient: HttpClient, tenantId: string, commentId: string, voteId: string, urlId: string, broadcastId: string, editKey: string, sso: string): (Option[DeleteCommentVote_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("urlId", $urlId))
  query_params_list.add(("broadcastId", $broadcastId))
  if $editKey != "":
    query_params_list.add(("editKey", $editKey))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.delete(basepath & fmt"/comments/{tenantId}/{commentId}/vote/{voteId}" & "?" & url_encoded_query_params)
  constructResult[DeleteCommentVote_200_response](response)


proc deleteFeedPostPublic*(httpClient: HttpClient, tenantId: string, postId: string, broadcastId: string, sso: string): (Option[DeleteFeedPostPublic_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  if $broadcastId != "":
    query_params_list.add(("broadcastId", $broadcastId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.delete(basepath & fmt"/feed-posts/{tenantId}/{postId}" & "?" & url_encoded_query_params)
  constructResult[DeleteFeedPostPublic_200_response](response)


proc flagCommentPublic*(httpClient: HttpClient, tenantId: string, commentId: string, isFlagged: bool, sso: string): (Option[FlagCommentPublic_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  query_params_list.add(("isFlagged", $isFlagged))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/flag-comment/{commentId}" & "?" & url_encoded_query_params)
  constructResult[FlagCommentPublic_200_response](response)


proc getCommentText*(httpClient: HttpClient, tenantId: string, commentId: string, editKey: string, sso: string): (Option[GetCommentText_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  if $editKey != "":
    query_params_list.add(("editKey", $editKey))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/comments/{tenantId}/{commentId}/text" & "?" & url_encoded_query_params)
  constructResult[GetCommentText_200_response](response)


proc getCommentVoteUserNames*(httpClient: HttpClient, tenantId: string, commentId: string, dir: int, sso: string): (Option[GetCommentVoteUserNames_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("dir", $dir))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/comments/{tenantId}/{commentId}/votes" & "?" & url_encoded_query_params)
  constructResult[GetCommentVoteUserNames_200_response](response)


proc getCommentsPublic*(httpClient: HttpClient, tenantId: string, urlId: string, page: int, direction: SortDirections, sso: string, skip: int, skipChildren: int, limit: int, limitChildren: int, countChildren: bool, fetchPageForCommentId: string, includeConfig: bool, countAll: bool, includei10n: bool, locale: string, modules: string, isCrawler: bool, includeNotificationCount: bool, asTree: bool, maxTreeDepth: int, useFullTranslationIds: bool, parentId: string, searchText: string, hashTags: seq[string], userId: string, customConfigStr: string, afterCommentId: string, beforeCommentId: string): (Option[GetCommentsPublic_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("urlId", $urlId))
  if $page != "":
    query_params_list.add(("page", $page))
  if $direction != "":
    query_params_list.add(("direction", $direction))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  if $skip != "":
    query_params_list.add(("skip", $skip))
  if $skipChildren != "":
    query_params_list.add(("skipChildren", $skipChildren))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $limitChildren != "":
    query_params_list.add(("limitChildren", $limitChildren))
  if $countChildren != "":
    query_params_list.add(("countChildren", $countChildren))
  if $fetchPageForCommentId != "":
    query_params_list.add(("fetchPageForCommentId", $fetchPageForCommentId))
  if $includeConfig != "":
    query_params_list.add(("includeConfig", $includeConfig))
  if $countAll != "":
    query_params_list.add(("countAll", $countAll))
  if $includei10n != "":
    query_params_list.add(("includei10n", $includei10n))
  if $locale != "":
    query_params_list.add(("locale", $locale))
  if $modules != "":
    query_params_list.add(("modules", $modules))
  if $isCrawler != "":
    query_params_list.add(("isCrawler", $isCrawler))
  if $includeNotificationCount != "":
    query_params_list.add(("includeNotificationCount", $includeNotificationCount))
  if $asTree != "":
    query_params_list.add(("asTree", $asTree))
  if $maxTreeDepth != "":
    query_params_list.add(("maxTreeDepth", $maxTreeDepth))
  if $useFullTranslationIds != "":
    query_params_list.add(("useFullTranslationIds", $useFullTranslationIds))
  if $parentId != "":
    query_params_list.add(("parentId", $parentId))
  if $searchText != "":
    query_params_list.add(("searchText", $searchText))
  if hashTags.len > 0:
    query_params_list.add(("hashTags", $hashTags.join(",")))
  if $userId != "":
    query_params_list.add(("userId", $userId))
  if $customConfigStr != "":
    query_params_list.add(("customConfigStr", $customConfigStr))
  if $afterCommentId != "":
    query_params_list.add(("afterCommentId", $afterCommentId))
  if $beforeCommentId != "":
    query_params_list.add(("beforeCommentId", $beforeCommentId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/comments/{tenantId}" & "?" & url_encoded_query_params)
  constructResult[GetCommentsPublic_200_response](response)


proc getEventLog*(httpClient: HttpClient, tenantId: string, urlId: string, userIdWS: string, startTime: int64, endTime: int64): (Option[GetEventLog_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("urlId", $urlId))
  query_params_list.add(("userIdWS", $userIdWS))
  query_params_list.add(("startTime", $startTime))
  query_params_list.add(("endTime", $endTime))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/event-log/{tenantId}" & "?" & url_encoded_query_params)
  constructResult[GetEventLog_200_response](response)


proc getFeedPostsPublic*(httpClient: HttpClient, tenantId: string, afterId: string, limit: int, tags: seq[string], sso: string, isCrawler: bool, includeUserInfo: bool): (Option[GetFeedPostsPublic_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  if $afterId != "":
    query_params_list.add(("afterId", $afterId))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if tags.len > 0:
    query_params_list.add(("tags", $tags.join(",")))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  if $isCrawler != "":
    query_params_list.add(("isCrawler", $isCrawler))
  if $includeUserInfo != "":
    query_params_list.add(("includeUserInfo", $includeUserInfo))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/feed-posts/{tenantId}" & "?" & url_encoded_query_params)
  constructResult[GetFeedPostsPublic_200_response](response)


proc getFeedPostsStats*(httpClient: HttpClient, tenantId: string, postIds: seq[string], sso: string): (Option[GetFeedPostsStats_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("postIds", $postIds.join(",")))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/feed-posts/{tenantId}/stats" & "?" & url_encoded_query_params)
  constructResult[GetFeedPostsStats_200_response](response)


proc getGlobalEventLog*(httpClient: HttpClient, tenantId: string, urlId: string, userIdWS: string, startTime: int64, endTime: int64): (Option[GetEventLog_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("urlId", $urlId))
  query_params_list.add(("userIdWS", $userIdWS))
  query_params_list.add(("startTime", $startTime))
  query_params_list.add(("endTime", $endTime))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/event-log/global/{tenantId}" & "?" & url_encoded_query_params)
  constructResult[GetEventLog_200_response](response)


proc getUserNotificationCount*(httpClient: HttpClient, tenantId: string, sso: string): (Option[GetUserNotificationCount_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/user-notifications/get-count" & "?" & url_encoded_query_params)
  constructResult[GetUserNotificationCount_200_response](response)


proc getUserNotifications*(httpClient: HttpClient, tenantId: string, pageSize: int, afterId: string, includeContext: bool, afterCreatedAt: int64, unreadOnly: bool, dmOnly: bool, noDm: bool, includeTranslations: bool, sso: string): (Option[GetUserNotifications_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $pageSize != "":
    query_params_list.add(("pageSize", $pageSize))
  if $afterId != "":
    query_params_list.add(("afterId", $afterId))
  if $includeContext != "":
    query_params_list.add(("includeContext", $includeContext))
  if $afterCreatedAt != "":
    query_params_list.add(("afterCreatedAt", $afterCreatedAt))
  if $unreadOnly != "":
    query_params_list.add(("unreadOnly", $unreadOnly))
  if $dmOnly != "":
    query_params_list.add(("dmOnly", $dmOnly))
  if $noDm != "":
    query_params_list.add(("noDm", $noDm))
  if $includeTranslations != "":
    query_params_list.add(("includeTranslations", $includeTranslations))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/user-notifications" & "?" & url_encoded_query_params)
  constructResult[GetUserNotifications_200_response](response)


proc getUserPresenceStatuses*(httpClient: HttpClient, tenantId: string, urlIdWS: string, userIds: string): (Option[GetUserPresenceStatuses_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  query_params_list.add(("urlIdWS", $urlIdWS))
  query_params_list.add(("userIds", $userIds))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/user-presence-status" & "?" & url_encoded_query_params)
  constructResult[GetUserPresenceStatuses_200_response](response)


proc getUserReactsPublic*(httpClient: HttpClient, tenantId: string, postIds: seq[string], sso: string): (Option[GetUserReactsPublic_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  if postIds.len > 0:
    query_params_list.add(("postIds", $postIds.join(",")))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/feed-posts/{tenantId}/user-reacts" & "?" & url_encoded_query_params)
  constructResult[GetUserReactsPublic_200_response](response)


proc lockComment*(httpClient: HttpClient, tenantId: string, commentId: string, broadcastId: string, sso: string): (Option[LockComment_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("broadcastId", $broadcastId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}/{commentId}/lock" & "?" & url_encoded_query_params)
  constructResult[LockComment_200_response](response)


proc pinComment*(httpClient: HttpClient, tenantId: string, commentId: string, broadcastId: string, sso: string): (Option[PinComment_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("broadcastId", $broadcastId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}/{commentId}/pin" & "?" & url_encoded_query_params)
  constructResult[PinComment_200_response](response)


proc reactFeedPostPublic*(httpClient: HttpClient, tenantId: string, postId: string, reactBodyParams: ReactBodyParams, isUndo: bool, broadcastId: string, sso: string): (Option[ReactFeedPostPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  if $isUndo != "":
    query_params_list.add(("isUndo", $isUndo))
  if $broadcastId != "":
    query_params_list.add(("broadcastId", $broadcastId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/feed-posts/{tenantId}/react/{postId}" & "?" & url_encoded_query_params, $(%reactBodyParams))
  constructResult[ReactFeedPostPublic_200_response](response)


proc resetUserNotificationCount*(httpClient: HttpClient, tenantId: string, sso: string): (Option[ResetUserNotifications_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & "/user-notifications/reset-count" & "?" & url_encoded_query_params)
  constructResult[ResetUserNotifications_200_response](response)


proc resetUserNotifications*(httpClient: HttpClient, tenantId: string, afterId: string, afterCreatedAt: int64, unreadOnly: bool, dmOnly: bool, noDm: bool, sso: string): (Option[ResetUserNotifications_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $afterId != "":
    query_params_list.add(("afterId", $afterId))
  if $afterCreatedAt != "":
    query_params_list.add(("afterCreatedAt", $afterCreatedAt))
  if $unreadOnly != "":
    query_params_list.add(("unreadOnly", $unreadOnly))
  if $dmOnly != "":
    query_params_list.add(("dmOnly", $dmOnly))
  if $noDm != "":
    query_params_list.add(("noDm", $noDm))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & "/user-notifications/reset" & "?" & url_encoded_query_params)
  constructResult[ResetUserNotifications_200_response](response)


proc searchUsers*(httpClient: HttpClient, tenantId: string, urlId: string, usernameStartsWith: string, mentionGroupIds: seq[string], sso: string): (Option[SearchUsers_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("urlId", $urlId))
  query_params_list.add(("usernameStartsWith", $usernameStartsWith))
  if mentionGroupIds.len > 0:
    query_params_list.add(("mentionGroupIds", $mentionGroupIds.join(",")))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/user-search/{tenantId}" & "?" & url_encoded_query_params)
  constructResult[SearchUsers_200_response](response)


proc setCommentText*(httpClient: HttpClient, tenantId: string, commentId: string, broadcastId: string, commentTextUpdateRequest: CommentTextUpdateRequest, editKey: string, sso: string): (Option[SetCommentText_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("broadcastId", $broadcastId))
  if $editKey != "":
    query_params_list.add(("editKey", $editKey))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}/{commentId}/update-text" & "?" & url_encoded_query_params, $(%commentTextUpdateRequest))
  constructResult[SetCommentText_200_response](response)


proc unBlockCommentPublic*(httpClient: HttpClient, tenantId: string, commentId: string, publicBlockFromCommentParams: PublicBlockFromCommentParams, sso: string): (Option[UnBlockCommentPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)
  let response = httpClient.request(basepath & fmt"/block-from-comment/{commentId}" & "?" & url_encoded_query_params, httpMethod = HttpDelete, body = $(%publicBlockFromCommentParams))
  constructResult[UnBlockCommentPublic_200_response](response)


proc unLockComment*(httpClient: HttpClient, tenantId: string, commentId: string, broadcastId: string, sso: string): (Option[LockComment_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("broadcastId", $broadcastId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}/{commentId}/unlock" & "?" & url_encoded_query_params)
  constructResult[LockComment_200_response](response)


proc unPinComment*(httpClient: HttpClient, tenantId: string, commentId: string, broadcastId: string, sso: string): (Option[PinComment_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("broadcastId", $broadcastId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}/{commentId}/unpin" & "?" & url_encoded_query_params)
  constructResult[PinComment_200_response](response)


proc updateFeedPostPublic*(httpClient: HttpClient, tenantId: string, postId: string, updateFeedPostParams: UpdateFeedPostParams, broadcastId: string, sso: string): (Option[CreateFeedPostPublic_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  if $broadcastId != "":
    query_params_list.add(("broadcastId", $broadcastId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.put(basepath & fmt"/feed-posts/{tenantId}/{postId}" & "?" & url_encoded_query_params, $(%updateFeedPostParams))
  constructResult[CreateFeedPostPublic_200_response](response)


proc updateUserNotificationCommentSubscriptionStatus*(httpClient: HttpClient, tenantId: string, notificationId: string, optedInOrOut: string, commentId: string, sso: string): (Option[UpdateUserNotificationStatus_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  query_params_list.add(("commentId", $commentId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/user-notifications/{notificationId}/mark-opted/{optedInOrOut}" & "?" & url_encoded_query_params)
  constructResult[UpdateUserNotificationStatus_200_response](response)


proc updateUserNotificationPageSubscriptionStatus*(httpClient: HttpClient, tenantId: string, urlId: string, url: string, pageTitle: string, subscribedOrUnsubscribed: string, sso: string): (Option[UpdateUserNotificationStatus_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  query_params_list.add(("urlId", $urlId))
  query_params_list.add(("url", $url))
  query_params_list.add(("pageTitle", $pageTitle))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/user-notifications/set-subscription-state/{subscribedOrUnsubscribed}" & "?" & url_encoded_query_params)
  constructResult[UpdateUserNotificationStatus_200_response](response)


proc updateUserNotificationStatus*(httpClient: HttpClient, tenantId: string, notificationId: string, newStatus: string, sso: string): (Option[UpdateUserNotificationStatus_200_response], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("tenantId", $tenantId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/user-notifications/{notificationId}/mark/{newStatus}" & "?" & url_encoded_query_params)
  constructResult[UpdateUserNotificationStatus_200_response](response)


proc uploadImage*(httpClient: HttpClient, tenantId: string, file: string, sizePreset: SizePreset, urlId: string): (Option[UploadImageResponse], Response) =
  ## 
  httpClient.headers["Content-Type"] = "multipart/form-data"
  var query_params_list: seq[(string, string)] = @[]
  if $sizePreset != "":
    query_params_list.add(("sizePreset", $sizePreset))
  if $urlId != "":
    query_params_list.add(("urlId", $urlId))
  let url_encoded_query_params = encodeQuery(query_params_list)
  let multipart_data = newMultipartData({
    "file": $file, # 
  })

  let response = httpClient.post(basepath & fmt"/upload-image/{tenantId}" & "?" & url_encoded_query_params, multipart=multipart_data)
  constructResult[UploadImageResponse](response)


proc voteComment*(httpClient: HttpClient, tenantId: string, commentId: string, urlId: string, broadcastId: string, voteBodyParams: VoteBodyParams, sessionId: string, sso: string): (Option[VoteComment_200_response], Response) =
  ## 
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("urlId", $urlId))
  query_params_list.add(("broadcastId", $broadcastId))
  if $sessionId != "":
    query_params_list.add(("sessionId", $sessionId))
  if $sso != "":
    query_params_list.add(("sso", $sso))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/comments/{tenantId}/{commentId}/vote" & "?" & url_encoded_query_params, $(%voteBodyParams))
  constructResult[VoteComment_200_response](response)

